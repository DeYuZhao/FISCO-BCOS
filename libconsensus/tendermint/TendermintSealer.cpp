//
// Created by 赵德宇 on 2019-04-01.
//
#include "TendermintSealer.h"
#include <libdevcore/CommonJS.h>
#include <libdevcore/Worker.h>
#include <libethcore/CommonJS.h>
using namespace dev::eth;
using namespace dev::db;
using namespace dev::blockverifier;
using namespace dev::blockchain;
using namespace dev::p2p;
namespace dev
{
namespace consensus
{
void TendermintSealer::handleBlock()
{
    /// check the max transaction num of a block early when generate new block
    /// in case of the block is generated by the nextleader and the transaction num is over
    /// maxTransactionLimit
    if (m_sealing.block.getTransactionSize() > m_tendermintEngine->maxBlockTransactions())
    {
        TENDERMINTSEALER_LOG(DEBUG)
                << LOG_DESC("Drop block for the transaction num is over maxTransactionLimit")
                << LOG_KV("transaction_num", m_sealing.block.getTransactionSize())
                << LOG_KV("maxTransactionLimit", m_tendermintEngine->maxBlockTransactions());
        resetSealingBlock();
        /// notify to re-generate the block
        m_signalled.notify_all();
        m_blockSignalled.notify_all();
        return;
    }
    setBlock();
    TENDERMINTSEALER_LOG(INFO) << LOG_DESC("++++++++++++++++ Generating seal on")
                         << LOG_KV("blkNum", m_sealing.block.header().number())
                         << LOG_KV("tx", m_sealing.block.getTransactionSize())
                         << LOG_KV("nodeIdx", m_tendermintEngine->nodeIdx())
                         << LOG_KV("hash", m_sealing.block.header().hash().abridged());
    bool succ = m_tendermintEngine->generatePropose(m_sealing.block);
    if (!succ)
    {
        resetSealingBlock();
        /// notify to re-generate the block
        m_signalled.notify_all();
        m_blockSignalled.notify_all();
    }
    else if (m_tendermintEngine->shouldReset(m_sealing.block))
    {
        resetSealingBlock();
        m_signalled.notify_all();
        m_blockSignalled.notify_all();
    }
}
void TendermintSealer::setBlock()
{
    m_sealing.block.header().populateFromParent(
            m_blockChain->getBlockByNumber(m_blockChain->number())->header());
    resetSealingHeader(m_sealing.block.header());
    m_sealing.block.calTransactionRoot();
}

/**
* @brief: this node can generate block or not
* @return true: this node can generate block
* @return false: this node can't generate block
*/
bool TendermintSealer::shouldSeal()
{
    return Sealer::shouldSeal() && m_tendermintEngine->shouldSeal();
}
void TendermintSealer::start()
{
    TENDERMINTSEALER_LOG(DEBUG) << LOG_DESC("Start TendermintSealer");
    m_tendermintEngine->start();
    Sealer::start();
}
void TendermintSealer::stop()
{
    TENDERMINTSEALER_LOG(DEBUG) << LOG_DESC("Stop TendermintSealer");
    Sealer::stop();
    m_tendermintEngine->stop();
}

}
}
